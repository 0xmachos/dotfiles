#!/usr/bin/env bash
# dotfiles/bittersweet

# bittersweet
#   Configures macOS just the way I like it
# Tested on:
#   10.13.x

set -euo pipefail
# -e exit if any command returns non-zero status code
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/


function usage {

  echo -e "\\nConfigures macOS just the way I like it ü§ì\\n"
  echo "Usage:"
  echo "  checkefi            - Check integrity of the x86 flash chip firmware."
  echo "  defaults            - Write new system and application default settings"
  echo "  vmware              - Change VMWare defaultVMPath to '${HOME}/Virtual Machines'"
  echo "  dotfiles            - Symlink various config files into ${HOME}"
  echo "  gpgtools            - Install GPGTools"
  echo "  sublimetext         - Install Sublime Text"
  echo "  tower               - Install Tower"
  echo "  rocket              - Install Rocket üöÄ"
  echo "  splashy             - Install Splashy üåÑ"
  echo "  blockblock          - Install BlockBlock"
  echo "  oversight           - Install OverSight üì∏üé§"
  echo "  brew                - Install Homebrew, Homebrew-file and export HOMEBREW_BREWFILE" 
  echo "  brewfile {Brewfile} - Install Homebrew packages from Brewfile"
  echo "  shell               - Change shell to bash as installed by Brew"

  echo -e "\\n  \\033[0;31mhailmary\\033[0m   - Run every function in order listed above"

  exit 0
}

### Utility Functions ###
# download_application
# install_application
# objective_see_install

function download_application {

  # Download file using curl
  # download application "path_to_save_file_to" "url_to_download_from"

  local download_path=${1:-"unset"}
  local url=${2:-"unset"}
  local file_name
  file_name=$(echo "${download_path}" | awk -F '/' '{print $(NF)}')

  if [[ "${download_path}" == "unset" ]]; then
    echo "[‚ùå] 'file_name' var not set"
    exit 1

  elif [[ "${url}" == "unset" ]]; then
    echo "[‚ùå] 'url' var not set"
    exit 1
  fi

  echo "[üç∫] Downloading ${file_name}"
  
  if curl -L -o "${download_path}" "${url}"; then 
  # Download 
    echo "[‚úÖ] Successfully downloaded ${file_name}"
  else
    echo "[‚ùå] Failed to download ${file_name}"
    exit 1
  fi
}


function install_application {

    # Install Applications packaged as .dmg or .zip
    # Does not work for application which require an installer (.pkg)
    # Checks if .dmg or .zip then act accordingly
    # Checks signature on .app before installing

    local application_name=${1:-"unset"}
    local downloaded_file_path=${2:-"unset"}
    local downloaded_file_name
    downloaded_file_name="$(echo "${downloaded_file_path}" | awk -F '/' '{print $NF}')"


    if [[ "${downloaded_file_name}" == "unset" ]]; then
      echo "[‚ùå] 'downloaded_file_name' var not set"
      exit 1
    
    elif [[ "${application_name}" == "unset" ]]; then 
      echo "[‚ùå] 'application_name' var not set"
      exit 1
    
    elif [ ! -f "${downloaded_file_path}" ]; then
      echo "[‚ùå] ${downloaded_file_path} does not exist"
      exit 1
    fi 


    if file "${downloaded_file_path}" | grep --quiet 'Zip'; then
      # IF file is a Zip 

      echo "[üç∫] Attempting to unzip ${downloaded_file_name}"
      if unzip -qa "${downloaded_file_path}" -d "${HOME}/Downloads"; then
        # Attempt to unzip
        echo "[‚úÖ] Successfully unzipped ${downloaded_file_name}"
      else
        echo "[‚ùå] Failed to unzip ${downloaded_file_name}"
        exit 1
      fi

      echo "[üç∫] Attempting to validated the signature on .app"
      if pkgutil --check-signature "${HOME}/Downloads/${application_name}.app"; then
        # Check the .app is correctly signed
        echo "[‚úÖ] Successfully validated the signature on ${application_name}.app"
      else
        echo "[‚ùå] Failed to validate the signature on ${application_name}.app"
        exit 1
      fi

      echo "[üç∫] Attempting to copy ${application_name}.app into /Applications"
      if cp -Ri "${HOME}/Downloads/${application_name}.app" "/Applications"; then
        # Attempt to copy .app into /Applications 
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi

      ## Cleanup
      echo "[üç∫] Deleting ${downloaded_file_path}"
      # Delete the ZIP
      rm "${downloaded_file_path:?}"

      echo "[üç∫] Deleting ${HOME}/Downloads/${application_name}.app"
      # Delete the .app
      rm -r "${HOME:?}/Downloads/${application_name:?}.app"


    elif file "${downloaded_file_path}" | grep --quiet 'dmg'; then
      # IF file is a dmg

      local dmg_mount_path
      
      echo "[üç∫] Attempting to mount ${downloaded_file_path}"
      if hdiutil attach -quiet "${downloaded_file_path}"; then
        # Attempt to mount the DMG 
        echo "[‚úÖ] Successfully mounted ${downloaded_file_name}"

        # shellcheck disable=SC2086
        # Globbing is desired here, using it to avoid SC2010
        dmg_mount_path="$(echo /Volumes/${application_name}*)"

      else
        echo "[‚ùå] Failed to mount ${downloaded_file_path}"
        exit 1
      fi

      echo "[üç∫] Attempting to validated the signature on ${application_name}.app"
      if pkgutil --check-signature "${dmg_mount_path}/${application_name}.app"; then
        # Check the .app is correctly signed
        echo "[‚úÖ] Successfully validated the signature on ${application_name}.app"
      else
        echo "[‚ùå] Failed to validate the signature on ${application_name}.app"
        exit 1
      fi

      echo "[üç∫] Attempting to copy ${application_name}.app into /Applications"
      if cp -Ri "${dmg_mount_path}/${application_name}.app" "/Applications"; then
        # Attempt to copy .app into /Applications 
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi

      ## Cleanup 
      echo "[üç∫] Unmounting ${dmg_mount_path}"
      # Unmount the DMG
      hdiutil detach -quiet "${dmg_mount_path}"
      
      echo "[üç∫] Deleting ${downloaded_file_path}"
      # Delete the DMG
      rm "${downloaded_file_path:?}"

    fi  
}


function objective_see_install {

  local application_name=${1:-"unset"}
  local downloaded_file_path=${2:-"unset"}
  local downloaded_file_name
  file_name=$(echo "${downloaded_file_path}" | awk -F '/' '{print $(NF)}')


  if [[ "${application_name}" == "unset" ]]; then 
    echo "[‚ùå] 'application_name' var not set"
    exit 1

  elif [[ "${downloaded_file_path}" == "unset" ]]; then
    echo "[‚ùå] 'downloaded_file_path' var not set"
    exit 1
  fi 

  echo "[üç∫] Attempting to unzip ${downloaded_file_path}"
  if unzip -qa "${downloaded_file_path}" -d "${HOME}/Downloads"; then
    # Attempt to unzip
    echo "[‚úÖ] Successfully unzipped ${downloaded_file_name}"
  else
    echo "[‚ùå] Failed to unzip ${downloaded_file_name}"
    exit 1
  fi

  echo "[üç∫] Attempting to validated the signature on ${application_name}_Installer.app"
  if pkgutil --check-signature "${HOME}/Downloads/${application_name}_Installer.app"; then
    # Check the .app is correctly signed
    echo "[‚úÖ] Successfully validated the signature on ${application_name}_Installer.app"
  else
    echo "[‚ùå] Failed to validate the signature on ${application_name}_Installer.app"
    exit 1
  fi

  (
    # Execute in a subshell so the working directory is not permanantly changed
    cd "${HOME}/Downloads" || exit

    echo "[‚ö†Ô∏è ] Password required to install ${application_name}"

    if [[ "${application_name}" == "OverSight" ]]; then

      if sudo bash -c "./${application_name}_Installer.app/Contents/MacOS/${application_name}_Installer -install"; then
      # OverSight's binary is named differently than other OBJSEE apps 
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi

    else 

      if sudo bash -c "./${application_name}_Installer.app/Contents/MacOS/${application_name} -install"; then 
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi

    fi
  )
}


function verify_sha {

  local file_name=${1:-"unset"}
  local file_download_path=${2:-"unset"}
  local file_sha_length=${3:-"unset"}
  local file_sha=${4:-"unset"}

  if [[ "${file_name}" == "unset" ]]; then
    echo "[‚ùå] 'file_name' var not set"
    exit 1

  elif [[ "${file_download_path}" == "unset" ]]; then 
    echo "[‚ùå] 'file_download_path' var not set"
    exit 1

  elif [[ ! "${file_sha_length}" =~ ^(1|256)$ ]]; then
    echo "[‚ùå] ${file_sha_length} muct be 1 or 256"
    exit 1

  elif [[ "${file_sha}" == "unset" ]]; then
    echo "[‚ùå] ${file_sha} does not exist"
    exit 1
  fi 

  echo "[üç∫] Attempting to validate ${file_name} SHA${file_sha_length} hash"

  echo "${file_sha}  ${file_name}" > "${file_download_path}.sha${file_sha_length}"

  (
    # Execute in a subshell so the working directory is not permanantly changed

    cd "${HOME}/Downloads" || exit

    if shasum -a "${file_sha_length}" -c "${file_download_path}.sha${file_sha_length}"; then 
    # Attempt to validate the ZIPs SHA256 hash
      echo "[‚úÖ] Successfully validated ${file_name} SHA${file_sha_length} hash"
    else
      echo "[‚ùå] Failed to validate ${file_name} SHA${file_sha_length} hash"
      exit 1
    fi

  )

  rm "${file_download_path:?}.sha${file_sha_length}"
}


### END Utility Functions ###


function check_efi_integrity {

  if /usr/libexec/firmwarecheckers/eficheck/eficheck --integrity-check; then 
    echo "[‚úÖ] Successfully verified EFI firmware integrity"
  else
    echo "[‚ùå] Failed to verify EFI firmware integrity"
    exit 1
  fi
}


function write_defaults {

  echo "[üç∫] Writing system & application defaults"
  echo "[‚ö†Ô∏è ] Password required to invoke defaults with sudo"

  defaults write com.apple.TextEdit RichText -int 0
  # TextEdit: Use Plain Text Mode as Default
  # Default: com.apple.TextEdit RichText -int 1

  defaults write com.apple.mail minSizeKB 5000
  # Mail: If attatchment is over 5MB ask to send via Mail Drop
  # Default: com.apple.mail minSizeKB 20000

  defaults write com.apple.menuextra.battery ShowPercent -string "YES"
  # Menu Bar: Show battery percentage
  # Default: com.apple.menuextra.battery ShowPercent -string "NO"

  defaults write -g NSNavPanelExpandedStateForSaveMode -bool true
  defaults write -g NSNavPanelExpandedStateForSaveMode2 -bool true
  # Save Panel: Show expanded version 
  # Default: defaults write -g NSNavPanelExpandedStateForSaveMode -bool false && \
  # defaults write -g NSNavPanelExpandedStateForSaveMode2 -bool false

  defaults write com.apple.finder ShowStatusBar -bool true
  # Finder: Show the status bar
  # Default: defaults write com.apple.finder ShowStatusBar -bool false

  defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool true
  # Trackpad: Enable three finger drag
  # Default: defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool false

  defaults write com.apple.AppleMultitouchTrackpad Clicking -bool true
  # Trackpad: Enable tap to click
  # Default: defaults write com.apple.AppleMultitouchTrackpad Clicking -bool false

  sudo defaults write /Library/Preferences/com.apple.AppleFileServer guestAccess -bool false
  # !! SUDO !!
  # Guest User: Disable
  # Default: sudo defaults write /Library/Preferences/com.apple.AppleFileServer guestAccess -bool true

  defaults write com.apple.menuextra.clock DateFormat -string "EEE d MMM  HH:mm"
  # Clock: Set format to Sun 26 Nov 16:00 

  defaults write com.apple.lookup.shared LookupSuggestionsDisabled -bool true
  # Spotlight: Disable suggestions in Lookup
  # Default: defaults write com.apple.lookup.shared LookupSuggestionsDisabled -bool false

  defaults write com.apple.Terminal SecureKeyboardEntry -bool true
  # Terminal: Enable Secure Keyboard Entry
  # Deafult: defaults write com.apple.Terminal SecureKeyboardEntry -bool false

  sudo defaults write /Library/Preferences/com.apple.alf globalstate -bool true
  # !! SUDO !!
  # Firewall: Enable
  # Default: sudo defaults write /Library/Preferences/com.apple.alf globalstate -bool falee

  defaults write com.apple.mail-shared DisableURLLoading -bool true
  # Mail: Disable "Load remote content in messages"
  # Default: defaults write com.apple.mail-shared DisableURLLoading -bool false

  defaults write com.apple.mail PreferPlainText -bool true
  # Mail: Force emails to be opened in plain text
  # Default: defaults write com.apple.mail PreferPlainText -bool false

  defaults write com.apple.SoftwareUpdate ScheduleFrequency -int 1
  # App Store: Check for updates everyday instead of every 7
  # Default: defaults write com.apple.SoftwareUpdate ScheduleFrequency -int 7
}


function change_vmware_home {

  # Create new directory $HOME/Virtual Machines
  # Set prefvmx.defaultVMPath to $HOME/Virtual Machines in ~/Library/Preferences/VMWare Fusion/preferences
  # TODO: Allow user to pass their own path for prefvmx_defaultVMPath  

  local vmware_preferences_file="${HOME}/Library/Preferences/VMware Fusion/preferences"
  local vmware_preferences_directory="${HOME}/Library/Preferences/VMware Fusion"
  local prefvmx_defaultVMPath="${HOME}/VMware Fusion"

  if [ ! -d "${vmware_preferences_directory}" ]; then
    # Check if VMWare Fusion is installed
    echo "[‚ùå] VMWare Fusion is not installed"
  else
    
    if grep -q "prefvmx.defaultVMPath" "${vmware_preferences_file}"; then
      # Check if prefvmx.defaultVMPath is already set
      echo "[‚ùå] prefvmx.defaultVMPath is already set"
      exit 1
    else
      echo "[üç∫] Setting VMWare prefvmx.defaultVMPath to '${prefvmx_defaultVMPath}'"

      if mkdir -p "${prefvmx_defaultVMPath}"; then
        # Attempt to create the directory for VM storage 
        echo "[‚úÖ] Successfully created '${prefvmx_defaultVMPath}'"
        
        if echo "prefvmx.defaultVMPath = ${prefvmx_defaultVMPath}" >> "${vmware_preferences_file}"; then
          echo "[‚úÖ] Successfully set prefvmx.defaultVMPath"
        else
          echo "[‚ùå] Failed to set prefvmx.defaultVMPath to '${prefvmx_defaultVMPath}'"
          exit 1
        fi

      else
        echo "[‚ùå] Failed to create '${prefvmx_defaultVMPath}'"
        exit 1
      fi
    fi
  fi  
}


function install_dotfiles {

  local dir_name
  local dir_name_base
  local dot_file
  local dot_file_base
  local bin_file
  local bin_file_base


  # Create required directories 
  # ~/.ssh and ~/.gnupg
  # shellcheck disable=SC2044
  for dir_name in $(find "$(PWD)" -type d -maxdepth 1 -name ".*" \
                  -not -name '.git'); do
    
    if [ -d "${dir_name}" ] ; then
      dir_name_base=$(basename "${dir_name}");

      if mkdir -p "${HOME}/${dir_name_base}" ; then
        echo "[‚úÖ] Successfully created ${HOME}/${dir_name_base}"
      else
        echo "[‚ùå] Failed to create ${HOME}/${dir_name_base}"
      fi
    else
      echo "[‚ùå] ${dir_name} does not exists"
    fi

  done

  echo "[‚ö†Ô∏è ] Password required to interact with /usr/local/bin/"

  if sudo mkdir -p "/usr/local/bin/"; then
  # !! SUDO !!
    echo "[‚úÖ] Successfully created /usr/local/bin/"
  else
    echo "[‚ùå] Failed to create /usr/local/bin/"
  fi
    

  # Symlink general dotfiles into ~/
  # .bash_profile
  # .bashrc
  # shellcheck disable=SC2044
  for dot_file in $(find "$(PWD)" -name ".*" \
                  -not -name '.gitignore' \
                  -not -name '.travis.yml' \
                  -not -name '.git' \
                  -not -name '.ssh' \
                  -not -name '.gnupg' \
                  -not -name '.DS_Store'); do

    if [ -e "${dot_file}" ] ; then
      dot_file_base=$(basename "${dot_file}");

      if ln -sfn "${dot_file}" "${HOME}/${dot_file_base}"; then
        echo "[‚úÖ] Successfully linked ${dot_file} to ${HOME}/${dot_file_base}"
      else
        echo "[‚ùå] Failed to link ${dot_file} to ${HOME}/${dot_file_base}"
      fi
    else
      echo "[‚ùå] ${dot_file} does not exists"
    fi

  done

  # Symlink ssh config files in to ~/.ssh/
  # config
  # shellcheck disable=SC2044
  for dot_file in $(find "$(PWD)/.ssh" -name "*" \
                  -not -name ".ssh"); do

    if [ -e "${dot_file}" ] ; then
      dot_file_base=$(basename "${dot_file}");

      if ln -sfn "${dot_file}" "${HOME}/.ssh/${dot_file_base}"; then
        echo "[‚úÖ] Successfully linked ${dot_file} to ${HOME}/.ssh/${dot_file_base}"
      else
        echo "[‚ùå] Failed to link ${dot_file} to ${HOME}/.ssh/${dot_file_base}"
      fi
    else
      echo "[‚ùå] ${dot_file} does not exists"
    fi

  done


  # Symlink GPG config files in to ~/.gnupg/
  # shellcheck disable=SC2044
  for dot_file in $(find "$(PWD)/.gnupg" -name "*" \
                  -not -name ".gnupg"); do

    if [ -e "${dot_file}" ] ; then
      dot_file_base=$(basename "${dot_file}");

      if ln -sfn "${dot_file}" "${HOME}/.gnupg/${dot_file_base}"; then
        echo "[‚úÖ] Successfully linked ${dot_file} to ${HOME}/.gnupg/${dot_file_base}"
      else
        echo "[‚ùå] Failed to link ${dot_file} to ${HOME}/.gnupg/${dot_file_base}"
      fi
    else
      echo "[‚ùå] ${dot_file} does not exists"
    fi
  
  done


  # Symlink scripts into /usr/local/bin
  # shellcheck disable=SC2044  
  for bin_file in $(find "$(PWD)/bin" -name "*" \
                  -not -name "bin"); do

    if [ -e "${bin_file}" ]; then
      bin_file_base=$(basename "${bin_file}");

      if sudo ln -sfn "${bin_file}" "/usr/local/bin/${bin_file_base}"; then
      # !! SUDO !!
        echo "[‚úÖ] Successfully linked ${bin_file} to /usr/local/bin/${bin_file_base}"
      else
        echo "[‚ùå] Failed to link ${bin_file} to /usr/local/bin/${bin_file_base}"
      fi
    else
      echo "[‚ùå] ${bin_file} does not exists"
    fi

  done    
}


function install_gpgtools {
  
  if ! [ -x "$(command -v gpg2)" ]; then
    
    echo "[üç∫] Installing GPGTools (GPG Suite)"

    # shellcheck disable=SC2155
    local latest_version="$(curl -s "https://gpgtools.org/releases/gpgsuite/release-notes.html" \
                | grep -m 1 'class="version"' \
                | awk -F '"' '{print $(NF-1)}')"
    # Get the latest version string
    # Query the id field from the latest div class="version"
    local dmg_name="GPG_Suite-${latest_version}.dmg"
    local dmg_download_path="${HOME}/Downloads/${dmg_name}" 
    # shellcheck disable=SC2155
    local dmg_sha256="$(curl -s "https://gpgtools.org" \
              | grep -m 1 "SHA256" \
              | perl -nle "print $& if m{(?<=class='tooltiptext'>).*(?=</span></span>)}")"
    # Get the SHA256 hash of the latest DMG
    local dmg_mount_point="/Volumes/GPG Suite/" 

    echo "[üç∫] Downloading ${dmg_name}"
    if curl -o "${dmg_download_path}" "https://releases.gpgtools.org/${dmg_name}"; then 
    # Download 
      echo "[‚úÖ] Successfully downloaded ${dmg_name}"
    else
      echo "[‚ùå] Failed to download ${dmg_name}"
      exit 1
    fi

    verify_sha "${dmg_name}" "${dmg_download_path}" "256" "${dmg_sha256}"

    echo "[üç∫] Attempting to mount ${dmg_download_path}"
    if hdiutil attach -quiet "${dmg_download_path}"; then
    # Attempt to mount the DMG 
      echo "[‚úÖ] Successfully mounted ${dmg_name}"
    else
      echo "[‚ùå] Failed to mount ${dmg_name}"
      exit 1
    fi  

    echo "[üç∫] Attempting to validate the signature on the package"
    if pkgutil --check-signature "${dmg_mount_point}/Install.pkg"; then
    # Check PKG is correctly sogned
      echo "[‚úÖ] Successfully validated the signature on the package"
    else
      echo "[‚ùå] Failed to validate the signature on the package"
      exit 1
    fi
    
    echo "[‚ö†Ô∏è ] Password required for installer"
    if sudo installer -pkg "${dmg_mount_point}/Install.pkg" -target "/"; then
      # !! SUDO !!
      # Install
      echo "[‚úÖ] Successfully installed GPGTools"
    else
      echo "[‚ùå] Failed to install GPGTools"
      exit 1
    fi

    # Cleanup 
    echo "[üç∫] Unmounting ${dmg_mount_point}"
    hdiutil detach -quiet "${dmg_mount_point}"
    # Unmount the DMG
    
    echo "[üç∫] Deleting ${dmg_download_path}"
    rm "${dmg_download_path:?}"
    # Delete the DMG

  else
    echo "[üç∫] $(gpg2 --version | head -n 1) already installed"
  fi
}


function install_sublime_text {

  if [ ! -d "/Applications/Sublime Text.app" ]; then

    echo "[üç∫] Installing Sublime Text"

    local latest_build  
    latest_build="$(curl -s https://www.sublimetext.com/3 \
                | grep "Version:" \
                | awk '{print ($4+0)}')"
    # Get the latest build string
    # grep "Version:" \ : <p class="latest"><i>Version:</i> Build 3143</p>
    # awk '{print $4}' : 3143</p>
    # awk '{print ($4+0)}' : 3143
    # ($4+0) converts captured string to numeric
    local dmg_name="Sublime Text Build ${latest_build}.dmg"
    local dmg_download_path="${HOME}/Downloads/${dmg_name}"
    local dmg_mount_point="/Volumes/Sublime Text" 
    
    download_application "${dmg_download_path}" "https://download.sublimetext.com/Sublime%20Text%20Build%20${latest_build}.dmg"

    install_application "Sublime Text" "${dmg_download_path}"

    ## Install config files
    echo "[üç∫] Installing Sublime Text config files"
    if mkdir -p "$HOME/Library/Application Support/Sublime Text 3/Packages/"; then
      echo "[‚úÖ] Successfully created ~/Library/Application Support/Sublime Text 3/Packages/"
    else
      echo "[‚ùå] Failed to create ~/Library/Application Support/Sublime Text 3/Packages/"
      exit 1
    fi 

    if cp -r "../Sublime Text 3/Packages/User" "$HOME/Library/Application Support/Sublime Text 3/Packages"; then
      echo "[‚úÖ] Successfully installed Sublime Text config files"
    else
      echo "[‚ùå] Failed to install Sublime Text config files"
      exit 1
    fi

  else 
    echo "[üç∫] Sublime Text already installed"
  fi
}


function install_tower {

  if [ ! -d "/Applications/Tower.app" ]; then
    
    echo "[üç∫] Installing Tower"

    local url
    local zip_name
    local zip_download_path

    url="$(curl -s https://updates.fournova.com/tower2-mac/stable/releases/latest/download | awk -F '"' '{print $2}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $7}')"
    zip_download_path="${HOME}/Downloads/${zip_name}" 

    download_application "${zip_download_path}" "${url}"

    install_application "Tower" "${zip_download_path}"
  
  else 
    echo "[üç∫] Tower already installed"
  fi
}


install_rocket () {

  if [ ! -d "/Applications/Rocket.app" ]; then

    echo "[üç∫] Installing Rocket üöÄ"

    local url
    local dmg_name
    local dmg_download_path
    local dmg_mount_point

    url="$(curl -s https://matthewpalmer.net/rocket/ | grep "Download" | awk -F '"' '{print $4}')"
    dmg_name="Rocket.dmg"
    dmg_download_path="${HOME}/Downloads/${dmg_name}"
    dmg_mount_point="/Volumes/Rocket" 

    download_application "${dmg_download_path}" "${url}"

    install_application "Rocket" "${dmg_download_path}"

  else 
    echo "[üç∫] Rocket already installed"
  fi
}


function install_splashy {

  if [ ! -d "/Applications/Splashy.app" ]; then

    echo "[üç∫] Installing Splashy üì∑"

    local url
    local dmg_name 
    local dmg_download_path

    url="$(curl -s https://splashy.art/ | grep 'macOS' | awk -F '"' '{print $4}')"
    dmg_name="$(echo "${url}" | awk -F '/' '{print $4}')"
    dmg_download_path="${HOME}/Downloads/${dmg_name}"

    download_application "${dmg_download_path}" "${url}"

    install_application "Splashy" "${dmg_download_path}"

  else 
    echo "[üç∫] Splashy already installed"
  fi
}


function install_blockblock {

  # Install BlockBlock

  if [ ! -f "$HOME/Library/Preferences/com.objectiveSee.BlockBlock.plist" ]; then
    
    echo "[üç∫] Installing BlockBlock"
  
    local url
    local zip_name
    local zip_download_path
    local zip_sha1

    url="$(curl -s --compressed https://objective-see.com/products/blockblock.html \
           | grep -m 1 'downloads/BlockBlock' \
           | awk -F '"' '{print $2}')"
    zip_sha1="$(curl -s --compressed https://objective-see.com/products/blockblock.html \
                  | grep 'sha-1' \
                  | awk '{print $3}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $NF}')"
    zip_download_path="${HOME}/Downloads/${zip_name}"

    download_application "${zip_download_path}" "${url}"

    verify_sha "${zip_name}" "${zip_download_path}" "1" "${zip_sha1}"

    objective_see_install "BlockBlock" "${zip_download_path}"

    # Enable headless mode
    defaults write com.objectiveSee.BlockBlock headlessMode -int 1

  else
    echo "[üç∫] BlockBlock already installed"
  fi

}


function install_oversight {

  # Install OverSight

  if [ ! -f "$HOME/Library/Preferences/com.objective-see.OverSight.plist" ]; then

    echo "[üç∫] Installing OverSight üì∏üé§"

    local url
    local zip_name
    local zip_download_path
    local zip_sha1

    url="$(curl -s --compressed https://objective-see.com/products/oversight.html \
          | grep -m 1 'downloads/OverSight' \
          | awk -F '"' '{print $2}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $NF}')"
    zip_download_path="${HOME}/Downloads/${zip_name}"
    zip_sha1="$(curl -s --compressed https://objective-see.com/products/oversight.html \
              | grep 'sha-1' \
              | awk '{print $3}')"

    download_application "${zip_download_path}" "${url}"

    verify_sha "${zip_name}" "${zip_download_path}" "1" "${zip_sha1}"

    objective_see_install "OverSight" "${zip_download_path}"

    # Enable headless mode
    defaults write com.objective-see.OverSight runHeadless -int 1

  else
    echo "[üç∫] OverSight already installed"
  fi
} 


function install_brew {

  # Install Homebrew and Homebrew-file

  if ! [ -x "$(command -v brew)" ]; then

    echo "[üç∫] Installing Homebrew"
    echo -e "[‚ö†Ô∏è ] \\033[0;31mStick around\\033[0m - Requires you to press RETURN and input your password"
    sleep 5
      
      if /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"; then
        echo "[‚úÖ] Successfully installed Homebrew üçª"
      else
        echo "[‚ùå] Failed to install Homebrew üò¢"
        exit 1
      fi    

    else
      
      brew update
      brew upgrade
      brew cleanup
    fi

    echo "[üç∫] Installing Homebrew-file"

    if ! [ -x "$(command -v brew-file)" ]; then

      if brew install rcmdnk/file/brew-file; then
        echo "[‚úÖ] Successfully installed Homebrew-file"
      else
        echo "[‚ùå] Failed to install Homebrew-file"
        exit 1
      fi
    else
      echo "[üç∫] Homebrew-file already installed"
    fi 

}


function install_brewfile {

  # Install Homebrew packages from dotfiles/Brewfile
  # Will install programs from the Mac AppStore if user is logged in
  
  export HOMEBREW_BREWFILE="${homebrew_brewfile}"
  echo "[üç∫] Exported HOMEBREW_BREWFILE=${homebrew_brewfile}"

    echo "[üç∫] Installing Homebrew packages from Brewfile"
    echo "[‚ö†Ô∏è ] Password required for brew file install"

    if brew file install; then 
      echo "[‚úÖ] Successfully installed packages from Brewfile"
  else
    echo "[‚ùå] Failed to install packages from Brewfile"
    exit 1
  fi
}


function change_shell {

  # Change default shell to bash as installed by Brew
  # /usr/local/bin/bash instead of /bin/bash

  local new_shell
  new_shell="/usr/local/bin/bash"
  
  if [[ "$BASH" == "${new_shell}" ]]; then
    echo "[‚úÖ] Current shell is already '${new_shell}'"
  else
    echo "[‚ö†Ô∏è ] Password required to change shell"

    if [ -e "${new_shell}" ]; then
      sudo bash -c "echo ${new_shell} >> /etc/shells"
      # !! SUDO !!
      # Add new shell to list of allowed shells
      # https://unix.stackexchange.com/a/4833/271903
      if chsh -s "${new_shell}"; then
      # Change $USER shell
        echo "[‚úÖ] Successfully change default shell to ${new_shell}"
      else  
        echo "[‚ùå] Failed to change default shell to ${new_shell}"
      fi
    else
      echo "[‚ùå] Failed to change shell as '${new_shell}' does not exist"
    fi
  fi   
}


function run_test {

  ./test
}


function main {

  local cmd=${1:-"usage"}
  local homebrew_brewfile=${2:-${HOME}/Documents/Projects/dotfiles/Brewfile}

  if [[ "${cmd}" == "eficheck" ]]; then
    check_efi_integrity

  elif [[ "${cmd}" == "defaults" ]]; then
    write_defaults

  elif [[ "${cmd}" == "vmware" ]]; then
    change_vmware_home

  elif [[ "${cmd}" == "dotfiles" ]]; then
    install_dotfiles

  elif [[ "${cmd}" == "gpgtools" ]]; then 
    install_gpgtools

  elif [[ "${cmd}" == "sublimetext" ]]; then
    install_sublime_text 

  elif [[ "${cmd}" == "tower" ]]; then
    install_tower
  
  elif [[ "${cmd}" == "rocket" ]]; then
    install_rocket
  
  elif [[ "${cmd}" == "splashy" ]]; then
    install_splashy

  elif [[ "${cmd}" == "blockblock" ]]; then
    install_blockblock
  
  elif [[ "${cmd}" == "oversight" ]]; then
    install_oversight

  elif [[ "${cmd}" == "brew" ]]; then
    install_brew

  elif [[ "${cmd}" == "brewfile" ]]; then
    install_brewfile "${homebrew_brewfile}"

  elif [[ "${cmd}" == "shell" ]]; then
    change_shell

  elif [[ "${cmd}" == "test" ]]; then
    run_test

  elif [[ "${cmd}" == "hailmary" ]]; then
    # Execute all the functions
    # Order matters!
    # TODO: Manually adding new functions sucks 
    echo -e "[üç∫] \\033[0;31mHailmary\\033[0m engaged"
    sleep 3

    check_efi_integrity
    write_defaults
    change_vmware_home
    install_dotfiles
    install_gpgtools
    install_sublime_text
    install_tower
    install_rocket
    install_splashy
    install_blockblock
    install_brew
    install_brewfile "${homebrew_brewfile}"
    change_shell

  else
    usage
  fi
}

main "$@"