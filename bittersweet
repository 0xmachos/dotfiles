#!/usr/bin/env bash
# dotfiles/bittersweet

# bittersweet
#   Configures macOS just the way I like it
# Tested on:
#   10.13.x

set -euo pipefail
# -e exit if any command returns non-zero status code
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/


### Define Colours ###

tput sgr0; 
# reset colors

readonly RESET=$(tput sgr0);
readonly BOLD=$(tput bold);

readonly RED=$(tput setaf 1);

### END Colours ###


function usage {

  echo -e "\\nConfigures macOS just the way I like it ü§ì\\n"
  echo "Usage:"
  echo "  checkefi            - Check integrity of the x86 flash chip firmware."
  echo "  defaults            - Write new system and application default settings"
  echo "  vmware              - Change VMWare defaultVMPath to '${HOME}/Virtual Machines'"
  echo "  dotfiles            - Symlink various config files into ${HOME}"
  echo "  gpgtools            - Install GPGTools"
  echo "  sublimetext         - Install Sublime Text"
  echo "  tower               - Install Tower"
  echo "  splashy             - Install Splashy üåÑ"
  echo "  blockblock          - Install BlockBlock"
  echo "  oversight           - Install OverSight üì∏üé§"
  echo "  brew                - Install Homebrew, Homebrew-file and export HOMEBREW_BREWFILE" 
  echo "  brewfile {Brewfile} - Install Homebrew packages from Brewfile"
  echo "  shell               - Change shell to bash as installed by Brew"

  echo -e "\\n  ${RED}hailmary${RESET}            - ${BOLD}Run every function${RESET} in order listed above"

  exit 0
}


### Utility Functions ###
# check_os_compatibility
# check_developer_tools
# download_application
# verify_sha
# verify_signature
# install_application
# objective_see_install
# mas_helper
# check_sudo
# run_test


function check_os_compatibility {
  
  local os
  local current_macos_version
  local -r supported_macos_version="10.13"
  local -r supported_macos_name="High Sierra"
  
  os="$(uname -s)"

  if [[ "${os}" != "Darwin" ]]; then 
    echo "[‚ùå] This script was written for macOS"
    exit 1
  fi
  
  current_macos_version="$(sw_vers -productVersion | awk -F '.' '{print $1 "." $2}')";
  
  if [[ "${current_macos_version}" != "${supported_macos_version}" ]]; then
    echo "[‚ö†Ô∏è ] This scipt was written for macOS ${supported_macos_name} (${supported_macos_version})"
    sleep 3
  fi 
}


function check_developer_tools {

  if ! xcode-select -p >/dev/null 2>&1; then 
    echo "[‚ùå] Command line developer tools required"
    echo "[üç∫] Install via: xcode-select --install"
    exit 1
  fi

}


function download_application {

  # Download file using curl
  # download application "path_to_save_file_to" "url_to_download_from"

  local download_path=${1:?download_path not passed}
  local url=${2:?url not passed}
  local file_name
  file_name=$(echo "${download_path}" | awk -F '/' '{print $(NF)}')


  echo "[üç∫] Downloading ${file_name}"
  
  if curl -L -o "${download_path}" "${url}"; then 
  # Download 
    echo "[‚úÖ] Successfully downloaded ${file_name}"
  else
    echo "[‚ùå] Failed to download ${file_name}"
    exit 1
  fi
}


function verify_sha {

  local file_name=${1:?file_name not passed}
  local file_download_path=${2:?file_download_path not passed}
  local file_sha_length=${3:?file_sha_length not passsed}
  local file_sha=${4:?file_sha not passed}


  echo "[üç∫] Attempting to validate ${file_name} SHA${file_sha_length} hash"

  echo "${file_sha}  ${file_name}" > "${file_download_path}.sha${file_sha_length}"

  (
    # Execute in a subshell so the working directory is not permanantly changed

    cd "${HOME}/Downloads" || exit

    if shasum -a "${file_sha_length}" -c "${file_download_path}.sha${file_sha_length}" >/dev/null; then 
    # Attempt to validate the ZIPs SHA256 hash
      echo "[‚úÖ] Successfully validated ${file_name} SHA${file_sha_length} hash"
    else
      echo "[‚ùå] Failed to validate ${file_name} SHA${file_sha_length} hash"
      exit 1
    fi

  )

  rm "${file_download_path:?}.sha${file_sha_length:?}"
}


function verify_signature {

  local application_path=${1:?application_path not passed}
  local application_name=${2:?application_name not passed}


  echo "[üç∫] Attempting to validated the signature on ${application_name}"

  if pkgutil --check-signature "${application_path}" >/dev/null; then
    # Check the .app is correctly signed
    echo "[‚úÖ] Successfully validated the signature on ${application_name}"
  else
    echo "[‚ùå] Failed to validate the signature on ${application_name}"
    exit 1
  fi
}


function install_application {

  # Install Applications packaged as .dmg or .zip
  # Does not work for application which require an installer (.pkg)
  # Checks if .dmg or .zip then act accordingly
  # Checks signature on .app before installing

  local application_name=${1:?application_name not passed}
  local downloaded_file_path=${2:?downloaded_file_path not passed}
  local downloaded_file_name
  local dmg_mount_path
  downloaded_file_name="$(echo "${downloaded_file_path}" | awk -F '/' '{print $NF}')"


  if file "${downloaded_file_path}" | grep --quiet 'Zip'; then
    # IF file is a Zip 

    echo "[üç∫] Attempting to unzip ${downloaded_file_name}"
    if unzip -qa "${downloaded_file_path}" -d "${HOME}/Downloads"; then
      # Attempt to unzip
      echo "[‚úÖ] Successfully unzipped ${downloaded_file_name}"
    else
      echo "[‚ùå] Failed to unzip ${downloaded_file_name}"
      exit 1
    fi

    verify_signature "${HOME}/Downloads/${application_name}.app" "${application_name}.app"

    echo "[üç∫] Attempting to copy ${application_name}.app into /Applications"
    if cp -Ri "${HOME}/Downloads/${application_name}.app" "/Applications"; then
      # Attempt to copy .app into /Applications 
      echo "[‚úÖ] Successfully installed ${application_name}"
    else
      echo "[‚ùå] Failed to install ${application_name}"
      exit 1
    fi

    ## Cleanup
    echo "[üç∫] Deleting ${downloaded_file_path}"
    # Delete the ZIP
    rm "${downloaded_file_path:?}"

    echo "[üç∫] Deleting ${HOME}/Downloads/${application_name}.app"
    # Delete the .app
    rm -r "${HOME:?}/Downloads/${application_name:?}.app"


  elif file "${downloaded_file_path}" | grep --quiet 'dmg'; then
    # IF file is a dmg
    
    echo "[üç∫] Attempting to mount ${downloaded_file_path}"
    if hdiutil attach -quiet "${downloaded_file_path}"; then
      # Attempt to mount the DMG 
      echo "[‚úÖ] Successfully mounted ${downloaded_file_name}"

      # shellcheck disable=SC2086
      # Globbing is desired here, using it to avoid SC2010
      dmg_mount_path="$(echo /Volumes/${application_name}*)"

    else
      echo "[‚ùå] Failed to mount ${downloaded_file_path}"
      exit 1
    fi

    verify_signature "${dmg_mount_path}/${application_name}.app" "${application_name}.app"

    echo "[üç∫] Attempting to copy ${application_name}.app into /Applications"
    if cp -Ri "${dmg_mount_path}/${application_name}.app" "/Applications"; then
      # Attempt to copy .app into /Applications 
      echo "[‚úÖ] Successfully installed ${application_name}"
    else
      echo "[‚ùå] Failed to install ${application_name}"
      exit 1
    fi

    ## Cleanup 
    echo "[üç∫] Unmounting ${dmg_mount_path}"
    # Unmount the DMG
    hdiutil detach -quiet "${dmg_mount_path}"
    
    echo "[üç∫] Deleting ${downloaded_file_path}"
    # Delete the DMG
    rm "${downloaded_file_path:?}"

  fi  
}


function objective_see_install {

  local application_name=${1:?application_name not passed}
  local downloaded_file_path=${2:?downloaded_file_path not passed}
  local downloaded_file_name
  downloaded_file_name=$(echo "${downloaded_file_path}" | awk -F '/' '{print $(NF)}')


  echo "[üç∫] Attempting to unzip ${downloaded_file_path}"
  if unzip -qa "${downloaded_file_path}" -d "${HOME}/Downloads"; then
    # Attempt to unzip
    echo "[‚úÖ] Successfully unzipped ${downloaded_file_name}"
  else
    echo "[‚ùå] Failed to unzip ${downloaded_file_name}"
    exit 1
  fi

  if [[ "${application_name}" == "BlockBlock" ]]; then
    # The BlockBlock installer binary name differs from every other ObjSee installer
    # This is a really shitty work around 
    verify_signature "${HOME}/Downloads/${application_name} Installer.app" "${application_name}"
  else

    verify_signature "${HOME}/Downloads/${application_name}_Installer.app" "${application_name}"
  fi

  (
    # Execute in a subshell so the working directory is not permanantly changed
    cd "${HOME}/Downloads" || exit

    if check_sudo; then
      echo "[‚ö†Ô∏è ] Password required to install ${application_name}"
    fi

    if [[ "${application_name}" == "OverSight" ]]; then

      if sudo bash -c "./${application_name}_Installer.app/Contents/MacOS/${application_name}_Installer -install"; then
      # OverSight's binary is named differently than other OBJSEE apps 
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi
    
    elif [[ "${application_name}" == "BlockBlock" ]]; then

      if sudo bash -c "./${application_name}\\ Installer.app/Contents/MacOS/${application_name} -install"; then
      # OverSight's binary is named differently than other OBJSEE apps 
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi

    else 

      if sudo bash -c "./${application_name}_Installer.app/Contents/MacOS/${application_name} -install"; then 
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi
    fi
  )
}


function mas_helper {

if ! brew install mas 2>/dev/null; then
  echo "[‚ùå] Failed to install mas"
  return 1
fi

if ! mas account >/dev/null; then
  echo "[‚ùå] Not signed into the App Store"
  echo "[üç∫] Sign in then rerun './bittersweet brewfile'"
  return 1
fi 
}


function check_sudo {

  # Check if the users password is needed to invoke sudo
  # If the password is required return 0
  # Example: 
  # if check_sudo; then 
  #   echo "Password required"
  # fi

  if ! sudo -n "echo" >/dev/null 2>&1; then
    # !! SUDO !!
    return 0
  else 
    return 1
  fi
}


function run_test {

  ./test
}


### END Utility Functions ###


function check_efi_integrity {

  if /usr/libexec/firmwarecheckers/eficheck/eficheck --integrity-check; then 
    echo "[‚úÖ] Successfully verified EFI firmware integrity"
  else
    echo "[‚ùå] Failed to verify EFI firmware integrity"
    exit 1
  fi
}


function write_defaults {

  echo "[üç∫] Writing system & application defaults"
  
  if check_sudo; then 
    echo "[‚ö†Ô∏è ] Password required to invoke defaults with sudo"
  fi


  defaults write com.apple.TextEdit RichText -bool false
  # TextEdit: Use Plain Text Mode as Default
  # Default: com.apple.TextEdit RichText -bool true

  defaults write com.apple.menuextra.battery ShowPercent -bool true
  # Menu Bar: Show battery percentage
  # Default: com.apple.menuextra.battery ShowPercent -bool false

  defaults write -g NSNavPanelExpandedStateForSaveMode -bool true
  defaults write -g NSNavPanelExpandedStateForSaveMode2 -bool true
  # Save Panel: Show expanded version 
  # Default: defaults write -g NSNavPanelExpandedStateForSaveMode -bool false && \
  # defaults write -g NSNavPanelExpandedStateForSaveMode2 -bool false

  defaults write com.apple.finder ShowStatusBar -bool true
  # Finder: Show the status bar
  # Default: defaults write com.apple.finder ShowStatusBar -bool false

  defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool true
  # Trackpad: Enable three finger drag
  # Default: defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool false

  defaults write com.apple.AppleMultitouchTrackpad Clicking -bool true
  # Trackpad: Enable tap to click
  # Default: defaults write com.apple.AppleMultitouchTrackpad Clicking -bool false

  sudo defaults write /Library/Preferences/com.apple.AppleFileServer guestAccess -bool false
  # !! SUDO !!
  # Guest User: Disable
  # Default: sudo defaults write /Library/Preferences/com.apple.AppleFileServer guestAccess -bool true

  defaults write com.apple.menuextra.clock DateFormat -string "EEE d MMM  HH:mm"
  # Clock: Set format to Sun 26 Nov 16:00 

  defaults write com.apple.lookup.shared LookupSuggestionsDisabled -bool true
  # Spotlight: Disable suggestions in Lookup
  # Default: defaults write com.apple.lookup.shared LookupSuggestionsDisabled -bool false

  defaults write com.apple.Terminal SecureKeyboardEntry -bool true
  # Terminal: Enable Secure Keyboard Entry
  # Deafult: defaults write com.apple.Terminal SecureKeyboardEntry -bool false

  sudo defaults write /Library/Preferences/com.apple.alf globalstate -bool true
  # !! SUDO !!
  # Firewall: Enable
  # Default: sudo defaults write /Library/Preferences/com.apple.alf globalstate -bool falee

  defaults write com.apple.mail-shared DisableURLLoading -bool true
  # Mail: Disable "Load remote content in messages"
  # Default: defaults write com.apple.mail-shared DisableURLLoading -bool false

  defaults write com.apple.mail PreferPlainText -bool true
  # Mail: Force emails to be opened in plain text
  # Default: defaults write com.apple.mail PreferPlainText -bool false

  defaults write com.apple.mail SendFormat -string Plain
  # Mail: Force new emails to be composed as plain text
  # Default: defaults write com.apple.mail SendFormat -string MIME

  defaults write com.apple.SoftwareUpdate ScheduleFrequency -int 1
  # App Store: Check for updates everyday instead of every 7
  # Default: defaults write com.apple.SoftwareUpdate ScheduleFrequency -int 7

  defaults write com.apple.mail minSizeKB 5000
  # Mail: If attatchment is over 5MB ask to send via Mail Drop
  # Default: com.apple.mail minSizeKB 20000
}


function change_vmware_home {

  # Create new directory $HOME/Virtual Machines
  # Set prefvmx.defaultVMPath to $HOME/Virtual Machines in ~/Library/Preferences/VMWare Fusion/preferences

  local prefvmx_defaultVMPath=${1:-"${HOME}/VMware Fusion"}
  local vmware_preferences_file="${HOME}/Library/Preferences/VMware Fusion/preferences"
  local vmware_preferences_directory="${HOME}/Library/Preferences/VMware Fusion"

  if [ ! -d "${vmware_preferences_directory}" ]; then
    # Check if VMWare Fusion is installed
    echo "[‚ùå] VMWare Fusion is not installed"
    return 0
  else
    
    if grep -q "prefvmx.defaultVMPath" "${vmware_preferences_file}"; then
      # Check if prefvmx.defaultVMPath is already set
      echo "[‚úÖ] prefvmx.defaultVMPath is already set"
      return 0
    else
      echo "[üç∫] Setting VMWare prefvmx.defaultVMPath to '${prefvmx_defaultVMPath}'"

      if mkdir -p "${prefvmx_defaultVMPath}"; then
        # Attempt to create the directory for VM storage 
        echo "[‚úÖ] Successfully created '${prefvmx_defaultVMPath}'"
        
        if echo "prefvmx.defaultVMPath = ${prefvmx_defaultVMPath}" >> "${vmware_preferences_file}"; then
          echo "[‚úÖ] Successfully set prefvmx.defaultVMPath"
        else
          echo "[‚ùå] Failed to set prefvmx.defaultVMPath to '${prefvmx_defaultVMPath}'"
          exit 1
        fi

      else
        echo "[‚ùå] Failed to create '${prefvmx_defaultVMPath}'"
        exit 1
      fi
    fi
  fi  
}


function install_dotfiles {

  local dir_name
  local dir_name_base
  local dot_file
  local dot_file_base
  local bin_file
  local bin_file_base
  local dir
  dir=$(pwd)


  # Create required directories 
  # ~/.ssh and ~/.gnupg
  while IFS= read -r -d '' dir_name; do
    
    if [ -d "${dir_name}" ] ; then
      dir_name_base=$(basename "${dir_name}");

      if mkdir -p "${HOME}/${dir_name_base}" ; then
        echo "[‚úÖ] Successfully created ${HOME}/${dir_name_base}"
      else
        echo "[‚ùå] Failed to create ${HOME}/${dir_name_base}"
      fi
    else
      echo "[‚ùå] ${dir_name} does not exists"
    fi

  done <   <(find . -type d -maxdepth 1 \
            -name ".*" \
            -not -name ".git" \
            -not -name "." \
            -print0)


  # Symlink general dotfiles into ~/
  # .bashrc, .extra, .bash_prompt
  # .exports, .bash_profile, .gitconfig
  # .aliases

  while read -r dot_file; do

    if [ -e "${dot_file}" ] ; then
      dot_file_base=$(basename "${dot_file}");

      if ln -sfn "${dir}/${dot_file_base}" "${HOME}/${dot_file_base}"; then
        echo "[‚úÖ] Successfully linked ${dir}/${dot_file_base} to ${HOME}/${dot_file_base}"
      else
        echo "[‚ùå] Failed to link ${dir}/${dot_file_base} to ${HOME}/${dot_file_base}"
      fi
    else
      echo "[‚ùå] ${dot_file} does not exists"
    fi

  done <   <(find . -type f -name ".*" \
                  -not -name '.gitignore' \
                  -not -name '.travis.yml' \
                  -not -name '.git' \
                  -not -name '.ssh' \
                  -not -name '.gnupg' \
                  -not -name '.DS_Store')


  # Symlink ssh config files in to ~/.ssh/
  # config

  while read -r dot_file; do

    if [ -e "${dot_file}" ] ; then
      dot_file_base=$(basename "${dot_file}");

      if ln -sfn "${dot_file}" "${HOME}/.ssh/${dot_file_base}"; then
        echo "[‚úÖ] Successfully linked ${dot_file} to ${HOME}/.ssh/${dot_file_base}"
      else
        echo "[‚ùå] Failed to link ${dot_file} to ${HOME}/.ssh/${dot_file_base}"
      fi
    else
      echo "[‚ùå] ${dot_file} does not exists"
    fi

  done <   <(find "$(PWD)/.ssh" -name "*" -not -name ".ssh")


  # Symlink GPG config files in to ~/.gnupg/
  # gpg-agent.conf, gpg.conf

  while read -r dot_file; do

    if [ -e "${dot_file}" ] ; then
      dot_file_base=$(basename "${dot_file}");

      if ln -sfn "${dot_file}" "${HOME}/.gnupg/${dot_file_base}"; then
        echo "[‚úÖ] Successfully linked ${dot_file} to ${HOME}/.gnupg/${dot_file_base}"
      else
        echo "[‚ùå] Failed to link ${dot_file} to ${HOME}/.gnupg/${dot_file_base}"
      fi
    else
      echo "[‚ùå] ${dot_file} does not exists"
    fi
  
  done <   <(find "$(PWD)/.gnupg" -name "*" -not -name ".gnupg")


  # Symlink bin/ scripts into /usr/local/bin
  # Check if /usr/local/bin exists, if not create it
  # Requires sudo to interact with /usr/local/bin

  if ! [[ -d "/usr/local/bin/" ]]; then 
    if check_sudo; then
      echo "[‚ö†Ô∏è ] Password required to create /usr/local/bin/"
    fi

    if sudo mkdir -p "/usr/local/bin/"; then
    # !! SUDO !!
      echo "[‚úÖ] Successfully created /usr/local/bin/"
    else
      echo "[‚ùå] Failed to create /usr/local/bin/"
    fi
  fi
 
  while read -r bin_file; do

    if [ -e "${bin_file}" ]; then
      bin_file_base=$(basename "${bin_file}");

      if check_sudo; then
        echo "[‚ö†Ô∏è ] Password required to symlink scripts into /usr/local/bin/"
      fi

      if sudo ln -sfn "${bin_file}" "/usr/local/bin/${bin_file_base}"; then
      # !! SUDO !!
        echo "[‚úÖ] Successfully linked ${bin_file} to /usr/local/bin/${bin_file_base}"
      else
        echo "[‚ùå] Failed to link ${bin_file} to /usr/local/bin/${bin_file_base}"
      fi
    else
      echo "[‚ùå] ${bin_file} does not exists"
    fi

  done <   <(find "$(PWD)/bin" -name "*" -not -name "bin" -not -name ".DS_Store")    
}


function install_gpgtools {
  
  if ! [ -x "$(command -v gpg2)" ]; then

    echo "[üç∫] Installing GPGTools (GPG Suite)"

    # shellcheck disable=SC2155
    local latest_version="$(curl -s "https://gpgtools.org/releases/gpgsuite/release-notes.html" \
                | grep -m 1 'class="version"' \
                | awk -F '"' '{print $(NF-1)}')"
    # Get the latest version string
    # Query the id field from the latest div class="version"
    local -r dmg_name="GPG_Suite-${latest_version}.dmg"
    local -r dmg_download_path="${HOME}/Downloads/${dmg_name}" 
    # shellcheck disable=SC2155
    local dmg_sha256="$(curl -s "https://gpgtools.org" 2>/dev/null \
              | grep -m 1 "SHA256" \
              | perl -nle "print $& if m{(?<=class='tooltiptext'>).*(?=</span></span>)}")"
    # Get the SHA256 hash of the latest DMG
    local -r dmg_mount_point="/Volumes/GPG Suite/" 

    echo "[üç∫] Downloading ${dmg_name}"
    if curl -o "${dmg_download_path}" "https://releases.gpgtools.org/${dmg_name}"; then 
    # Download 
      echo "[‚úÖ] Successfully downloaded ${dmg_name}"
    else
      echo "[‚ùå] Failed to download ${dmg_name}"
      exit 1
    fi

    verify_sha "${dmg_name}" "${dmg_download_path}" "256" "${dmg_sha256}"

    echo "[üç∫] Attempting to mount ${dmg_download_path}"
    if hdiutil attach -quiet "${dmg_download_path}"; then
    # Attempt to mount the DMG 
      echo "[‚úÖ] Successfully mounted ${dmg_name}"
    else
      echo "[‚ùå] Failed to mount ${dmg_name}"
      exit 1
    fi  

    verify_signature "${dmg_mount_point}/Install.pkg" "Install.pkg"
    
    if check_sudo; then
      echo "[‚ö†Ô∏è ] Password required for installer"
    fi

    if sudo installer -pkg "${dmg_mount_point}/Install.pkg" -target "/" >/dev/null; then
      # !! SUDO !!
      # Install
      echo "[‚úÖ] Successfully installed GPGTools"
    else
      echo "[‚ùå] Failed to install GPGTools"
      exit 1
    fi

    # Cleanup 
    echo "[üç∫] Unmounting ${dmg_mount_point}"
    hdiutil detach -quiet "${dmg_mount_point}"
    # Unmount the DMG
    
    echo "[üç∫] Deleting ${dmg_download_path}"
    rm "${dmg_download_path:?}"
    # Delete the DMG

  else
    echo "[üç∫] $(gpg2 --version | head -n 1) already installed"
  fi
}


function install_sublime_text {

  if [ ! -d "/Applications/Sublime Text.app" ]; then

    echo "[üç∫] Installing Sublime Text"

    local latest_build  
    latest_build="$(curl -s https://www.sublimetext.com/3 \
                | grep "Version:" \
                | awk '{print ($4+0)}')"
    # Get the latest build string
    # grep "Version:" \ : <p class="latest"><i>Version:</i> Build 3143</p>
    # awk '{print $4}' : 3143</p>
    # awk '{print ($4+0)}' : 3143
    # ($4+0) converts captured string to numeric
    local dmg_name="Sublime Text Build ${latest_build}.dmg"
    local dmg_download_path="${HOME}/Downloads/${dmg_name}"
    local dmg_mount_point="/Volumes/Sublime Text" 
    
    download_application "${dmg_download_path}" "https://download.sublimetext.com/Sublime%20Text%20Build%20${latest_build}.dmg"

    install_application "Sublime Text" "${dmg_download_path}"

    ## Install config files
    echo "[üç∫] Installing Sublime Text config files"

    if mkdir -p "$HOME/Library/Application Support/Sublime Text 3/Packages/"; then
      echo "[‚úÖ] Successfully created ~/Library/Application Support/Sublime Text 3/Packages/"
    else
      echo "[‚ùå] Failed to create ~/Library/Application Support/Sublime Text 3/Packages/"
      exit 1
    fi 

    if cp -r "Sublime Text 3/Packages/User" "$HOME/Library/Application Support/Sublime Text 3/Packages"; then
      echo "[‚úÖ] Successfully installed Sublime Text config files"
    else
      echo "[‚ùå] Failed to install Sublime Text config files"
      exit 1
    fi

  else 
    echo "[üç∫] Sublime Text already installed"
  fi
}


function install_tower {

  if [ ! -d "/Applications/Tower.app" ]; then
    
    echo "[üç∫] Installing Tower"

    local url
    local zip_name
    local zip_download_path

    url="$(curl -s https://updates.fournova.com/tower2-mac/stable/releases/latest/download | awk -F '"' '{print $2}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $7}')"
    zip_download_path="${HOME}/Downloads/${zip_name}" 

    download_application "${zip_download_path}" "${url}"

    install_application "Tower" "${zip_download_path}"
  
  else 
    echo "[üç∫] Tower already installed"
  fi
}


function install_splashy {

  if [ ! -d "/Applications/Splashy.app" ]; then

    echo "[üç∫] Installing Splashy üì∑"

    local url
    local dmg_name 
    local dmg_download_path

    url="$(curl -s https://splashy.art/ \
          | grep 'macOS' \
          | awk -F '"' '{print $4}')"
    dmg_name="$(echo "${url}" | awk -F '/' '{print $4}')"
    dmg_download_path="${HOME}/Downloads/${dmg_name}"

    download_application "${dmg_download_path}" "${url}"

    install_application "Splashy" "${dmg_download_path}"

  else 
    echo "[üç∫] Splashy already installed"
  fi
}


function install_blockblock {

  # Install BlockBlock

  if [ ! -f "$HOME/Library/Preferences/com.objectiveSee.BlockBlock.plist" ]; then
    
    echo "[üç∫] Installing BlockBlock"
  
    local url
    local zip_name
    local zip_download_path
    local zip_sha1

    url="$(curl -s --compressed https://objective-see.com/products/blockblock.html \
           | grep -m 1 'downloads/BlockBlock' \
           | awk -F '"' '{print $2}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $NF}')"
    zip_download_path="${HOME}/Downloads/${zip_name}"
    zip_sha1="$(curl -s --compressed https://objective-see.com/products/blockblock.html \
                  | grep 'sha-1' \
                  | awk '{print $3}')"

    download_application "${zip_download_path}" "${url}"

    verify_sha "${zip_name}" "${zip_download_path}" "1" "${zip_sha1}"

    objective_see_install "BlockBlock" "${zip_download_path}"

    # Enable headless mode
    defaults write com.objectiveSee.BlockBlock headlessMode -int 1

  else
    echo "[üç∫] BlockBlock already installed"
  fi
}


function install_oversight {

  # Install OverSight

  if [ ! -f "$HOME/Library/Preferences/com.objective-see.OverSight.plist" ]; then

    echo "[üç∫] Installing OverSight üì∏üé§"

    local url
    local zip_name
    local zip_download_path
    local zip_sha1

    url="$(curl -s --compressed https://objective-see.com/products/oversight.html \
          | grep -m 1 'downloads/OverSight' \
          | awk -F '"' '{print $2}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $NF}')"
    zip_download_path="${HOME}/Downloads/${zip_name}"
    zip_sha1="$(curl -s --compressed https://objective-see.com/products/oversight.html \
              | grep 'sha-1' \
              | awk '{print $3}')"

    download_application "${zip_download_path}" "${url}"

    verify_sha "${zip_name}" "${zip_download_path}" "1" "${zip_sha1}"

    objective_see_install "OverSight" "${zip_download_path}"

    # Enable headless mode
    defaults write com.objective-see.OverSight runHeadless -int 1

  else
    echo "[üç∫] OverSight already installed"
  fi
} 


function install_brew {

  # Install Homebrew and Homebrew-file

  if ! [ -x "$(command -v brew)" ]; then

    echo "[üç∫] Installing Homebrew"
    echo -e "[‚ö†Ô∏è ] \\033[0;31mStick around\\033[0m - Requires you to press RETURN and input your password"
    sleep 5

    if /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"; then
      echo "[‚úÖ] Successfully installed Homebrew üçª"
    else
      echo "[‚ùå] Failed to install Homebrew üò¢"
      exit 1
    fi    

  else

    echo "[üç∫] Updating Homebrew"
    sleep 2
    
    brew update
    brew upgrade
    brew cleanup
  fi

  echo "[üç∫] Installing Homebrew-file"

  if ! [ -x "$(command -v brew-file)" ]; then

    if brew install rcmdnk/file/brew-file; then
      echo "[‚úÖ] Successfully installed Homebrew-file"
    else
      echo "[‚ùå] Failed to install Homebrew-file"
      exit 1
    fi

  else
    echo "[üç∫] Homebrew-file already installed"
  fi 
}


function install_brewfile {

  # Install Homebrew packages from dotfiles/Brewfile
  # Will install programs from the Mac AppStore if user is logged in
  
  local HOMEBREW_BREWFILE=${1:-"${HOME}/Documents/Projects/dotfiles/Brewfile"}
  export HOMEBREW_BREWFILE="${HOMEBREW_BREWFILE}"

  echo "[üç∫] Exported HOMEBREW_BREWFILE=${HOMEBREW_BREWFILE}"
  echo "[üç∫] Installing Homebrew packages from Brewfile"
  
  if check_sudo; then 
    echo "[‚ö†Ô∏è ] Password required for brew file install"
  fi

  if brew file install; then 
    echo "[‚úÖ] Successfully installed packages from Brewfile"
  else
    echo "[‚ùå] Failed to install packages from Brewfile"
    exit 1
  fi
}


function change_shell {

  # Change default shell to bash as installed by Brew
  # /usr/local/bin/bash instead of /bin/bash

  local -r new_shell="/usr/local/bin/bash"
  
  if [[ "$BASH" == "${new_shell}" ]]; then
    echo "[‚úÖ] Current shell is already '${new_shell}'"
  else
    if check_sudo; then 
      echo "[‚ö†Ô∏è ] Password required to change shell"
    fi

    if [ -e "${new_shell}" ]; then
      sudo bash -c "echo ${new_shell} >> /etc/shells"
      # !! SUDO !!
      # Add new shell to list of allowed shells
      # https://unix.stackexchange.com/a/4833/271903
      if chsh -s "${new_shell}"; then
      # Change $USER shell
        echo "[‚úÖ] Successfully change default shell to ${new_shell}"
      else  
        echo "[‚ùå] Failed to change default shell to ${new_shell}"
      fi
    else
      echo "[‚ùå] Failed to change shell as '${new_shell}' does not exist"
    fi
  fi   
}


function main {

  check_os_compatibility
  check_developer_tools

  local cmd=${1:-"usage"}

  if [[ "${cmd}" == "eficheck" ]]; then
    check_efi_integrity

  elif [[ "${cmd}" == "defaults" ]]; then
    write_defaults

  elif [[ "${cmd}" == "vmware" ]]; then
    local prefvmx_defaultVMPath=${2:-"${HOME}/VMware Fusion"}
    change_vmware_home "${prefvmx_defaultVMPath}"

  elif [[ "${cmd}" == "dotfiles" ]]; then
    install_dotfiles

  elif [[ "${cmd}" == "gpgtools" ]]; then 
    install_gpgtools

  elif [[ "${cmd}" == "sublimetext" ]]; then
    install_sublime_text 

  elif [[ "${cmd}" == "tower" ]]; then
    install_tower

  elif [[ "${cmd}" == "splashy" ]]; then
    install_splashy

  elif [[ "${cmd}" == "blockblock" ]]; then
    install_blockblock
  
  elif [[ "${cmd}" == "oversight" ]]; then
    install_oversight

  elif [[ "${cmd}" == "brew" ]]; then
    install_brew

  elif [[ "${cmd}" == "brewfile" ]]; then
    local HOMEBREW_BREWFILE=${2:-"${HOME}/Documents/Projects/dotfiles/Brewfile"}
    mas_helper
    install_brewfile "${HOMEBREW_BREWFILE}"

  elif [[ "${cmd}" == "shell" ]]; then
    change_shell

  elif [[ "${cmd}" == "test" ]]; then
    run_test

  elif [[ "${cmd}" == "hailmary" ]]; then
    # Execute all the functions
    # Order matters!
    # TODO: Manually adding new functions sucks 
    echo -e "[üç∫] ${RED}Hailmary${RESET} engaged"
    sleep 3

    check_efi_integrity
    write_defaults
    change_vmware_home
    install_dotfiles
    install_gpgtools
    install_sublime_text
    install_tower
    install_splashy
    install_blockblock
    install_oversight
    install_brew
    mas_helper
    install_brewfile "${HOMEBREW_BREWFILE}"
    change_shell

  else
    usage
  fi
}

main "$@"
