#!/usr/bin/env zsh
# dotfiles/bittersweet

# bittersweet
#   Configures macOS just the way I like it

set -euo pipefail
# -e exit if any command returns non-zero status code
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

### Define Colours ###

/usr/bin/tput sgr0; 
# reset colors
readonly RESET=$(/usr/bin/tput sgr0);
readonly BOLD=$(/usr/bin/tput bold);
readonly RED=$(/usr/bin/tput setaf 1);

### END Colours ###


function usage {

  echo -e "\\nConfigures macOS just the way I like it ü§ì\\n"
  echo "Usage:"
  echo "  defaults              - Write new system and application default settings"
  echo "  dotfiles              - Symlink various config files into ${HOME}"
  echo "  scripts               - Symlink scripts in bin into /usr/local/bin"
  echo "  sudotouch             - Enable TouchID to sudo"
  echo "  gpgtools              - Install GPGTools"
  echo "  sublimetext           - Install Sublime Text"
  echo "  tower                 - Install Tower"
  echo "  deckset               - Install Deckset"
  echo "  blockblock            - Install BlockBlock"
  echo "  oversight             - Install OverSight üì∏üé§"
  echo "  brew                  - Install Homebrew, Homebrew-file and export HOMEBREW_BREWFILE" 
  echo "  brewfile              - Install Homebrew packages from Brewfile"
  echo "  shell                 - Change shell to bash as installed by Brew"

  echo -e "\\n  ${RED}hailmary${RESET}            - ${BOLD}Run every function${RESET} in order listed above"

  exit 0
}


### Utility Functions ###
# check_os_compatibility
# check_developer_tools
# download_application
# verify_sha
# verify_signature
# install_application
# objective_see_install
# get_sudo
# ctrl_c
# run_test


function check_os_compatibility {
  # check_os_compatibility
  #   Check if the host is darwin (i.e macOS)
  #   Check if the host is ruuning macOS $supported_macos_version

  local os
  local current_macos_version
  local -r supported_macos_version="10.15"
  local -r supported_macos_name="Catalina"
  
  os="$(uname -s)"

  if [[ "${os}" != "Darwin" ]]; then 
    echo "[‚ùå] This script was written for macOS"
    exit 1
  fi
  
  current_macos_version="$(sw_vers -productVersion | awk -F '.' '{print $1 "." $2}')";
  
  if [[ "${current_macos_version}" != "${supported_macos_version}" ]]; then
    echo "[‚ö†Ô∏è ] This scipt was written for macOS ${supported_macos_name} (${supported_macos_version})"
    sleep 3
  fi 
}


function check_developer_tools {

  if ! xcode-select -p >/dev/null 2>&1; then 
    echo "[‚ùå] Command line developer tools required"
    echo "[üç∫] Install via: xcode-select --install"
    exit 1
  fi
}


function download_application {
  # download_application
  #   download_application "download_path" "url"
  #   Download file using curl
  #   curl will follow redirects (--location)

  local download_path=${1:?download_path not passed to download_application}
  local url=${2:?url not passed to download_application}
  local file_name
  file_name=$(echo "${download_path}" | awk -F '/' '{print $(NF)}')

  echo "[üç∫] Downloading ${file_name}"
  
  if curl --location --silent "${url}" --output "${download_path}"; then 
  # Download 
    echo "[‚úÖ] Successfully downloaded ${file_name}"
  else
    echo "[‚ùå] Failed to download ${file_name}"
    return 1
  fi
}


function verify_sha {
  # verify_sha
  #   Uses shasum to check hash of file is what
  #   we expect it to be

  local file_name=${1:?file_name not passed to verify_sha}
  local file_download_path=${2:?file_download_path not passed to verify_sha}
  local file_sha_length=${3:?file_sha_length not passsed to verify_sha}
  local file_sha=${4:?file_sha not passed to verify_sha}


  echo "[üç∫] Attempting to validate ${file_name} SHA${file_sha_length} hash"

  echo "${file_sha}  ${file_name}" > "${file_download_path}.sha${file_sha_length}"

  (
    # Execute in a subshell so the working directory is not permanantly changed

    cd "${HOME}/Downloads" || exit

    if shasum -a "${file_sha_length}" -c "${file_download_path}.sha${file_sha_length}" >/dev/null; then 
    # Attempt to validate the ZIPs SHA256 hash
      echo "[‚úÖ] Successfully validated ${file_name} SHA${file_sha_length} hash"
    else
      echo "[‚ùå] Failed to validate ${file_name} SHA${file_sha_length} hash"
      exit 1
    fi

  )

  rm "${file_download_path:?}.sha${file_sha_length:?}"
}


function verify_signature {
  # verify_signature
  #   Check the crypographic signature of .app/ .pkg files
  #   before installing them
  # Paramters: 
  #   $application_path REQUIRED
  #     Path to .app or .pkg file
  #   $application_name REQUIRED
  #     Name of Application being installed

  local application_path=${1:?application_path not passed to verify_signature}
  local application_name=${2:?application_name not passed to verify_signature}

  if [[ "${application_path}" =~ .pkg ]]; then

    echo "[üç∫] Attempting to validated the signature on ${application_name}.pkg"
    
    if pkgutil --check-signature "${application_path}" >/dev/null; then 
      echo "[‚úÖ] Successfully validated the signaturee on ${application_name}.pkg"
    else
      echo "[‚ùå] Failed to validate the signature on ${application_name}.pkg"
      exit 1
    fi

  elif [[ "${application_path}" =~ .app ]]; then

    echo "[üç∫] Attempting to validated the signature on ${application_name}.app"

    if codesign --verify --deep --strict "${application_path}"; then
      # Check the .app is correctly signed
      echo "[‚úÖ] Successfully validated the signaturee on ${application_name}.app"
    else
      echo "[‚ùå] Failed to validate the signature on ${application_name}.app"
      exit 1
    fi
fi
}


function install_application {
  # install_application
  #   Install Applications packaged as .dmg or .zip
  #   Does not work for application which require an installer (.pkg)
  #   Checks if .dmg or .zip then act accordingly
  #   Checks signature on .app before installing

  local application_name=${1:?application_name not passed}
  local downloaded_file_path=${2:?downloaded_file_path not passed}
  local downloaded_file_name
  local dmg_mount_path
  downloaded_file_name="$(echo "${downloaded_file_path}" | awk -F '/' '{print $NF}')"


  if file "${downloaded_file_path}" | grep --quiet 'Zip'; then
    # IF file is a Zip 

    echo "[üç∫] Attempting to unzip ${downloaded_file_name}"
    if unzip -qa "${downloaded_file_path}" -d "${HOME}/Downloads"; then
      # Attempt to unzip
      echo "[‚úÖ] Successfully unzipped ${downloaded_file_name}"
    else
      echo "[‚ùå] Failed to unzip ${downloaded_file_name}"
      exit 1
    fi

    verify_signature "${HOME}/Downloads/${application_name}.app" "${application_name}"

    echo "[üç∫] Attempting to copy ${application_name}.app into /Applications"
    if cp -Ri "${HOME}/Downloads/${application_name}.app" "/Applications"; then
      # Attempt to copy .app into /Applications 
      echo "[‚úÖ] Successfully installed ${application_name}"
    else
      echo "[‚ùå] Failed to install ${application_name}"
      exit 1
    fi

    ## Cleanup
    echo "[üç∫] Deleting ${downloaded_file_path}"
    # Delete the ZIP
    rm "${downloaded_file_path:?}"

    echo "[üç∫] Deleting ${HOME}/Downloads/${application_name}.app"
    # Delete the .app
    rm -r "${HOME:?}/Downloads/${application_name:?}.app"


  elif file "${downloaded_file_path}" | grep --quiet 'dmg'; then
    # IF file is a dmg
    
    echo "[üç∫] Attempting to mount ${downloaded_file_path}"
    if hdiutil attach -quiet "${downloaded_file_path}"; then
      # Attempt to mount the DMG 
      echo "[‚úÖ] Successfully mounted ${downloaded_file_name}"

      # shellcheck disable=SC2086
      # Globbing is desired here, using it to avoid SC2010
      dmg_mount_path="$(echo /Volumes/${application_name}*)"

    else
      echo "[‚ùå] Failed to mount ${downloaded_file_path}"
      exit 1
    fi

    verify_signature "${dmg_mount_path}/${application_name}.app" "${application_name}"

    echo "[üç∫] Attempting to copy ${application_name}.app into /Applications"
    if cp -Ri "${dmg_mount_path}/${application_name}.app" "/Applications"; then
      # Attempt to copy .app into /Applications 
      echo "[‚úÖ] Successfully installed ${application_name}"
    else
      echo "[‚ùå] Failed to install ${application_name}"
      exit 1
    fi

    ## Cleanup 
    echo "[üç∫] Unmounting ${dmg_mount_path}"
    # Unmount the DMG
    hdiutil detach -quiet "${dmg_mount_path}"
    
    echo "[üç∫] Deleting ${downloaded_file_path}"
    # Delete the DMG
    rm "${downloaded_file_path:?}"

  fi  
}


function objective_see_install {

  local application_name=${1:?application_name not passed to objective_see_install}
  local downloaded_file_path=${2:?downloaded_file_path not passed objective_see_install}
  local downloaded_file_name
  downloaded_file_name=$(echo "${downloaded_file_path}" | awk -F '/' '{print $(NF)}')


  echo "[üç∫] Attempting to unzip ${downloaded_file_path}"
  if unzip -qa "${downloaded_file_path}" -d "${HOME}/Downloads"; then
    # Attempt to unzip
    echo "[‚úÖ] Successfully unzipped ${downloaded_file_name}"
  else
    echo "[‚ùå] Failed to unzip ${downloaded_file_name}"
    exit 1
  fi

  if [[ "${application_name}" == "BlockBlock" ]]; then
    # The BlockBlock installer binary name differs from every other ObjSee installer
    # This is a really shitty work around 
    verify_signature "${HOME}/Downloads/${application_name} Installer.app" "${application_name}"
  else
    verify_signature "${HOME}/Downloads/${application_name}_Installer.app" "${application_name}"
  fi

  (
    # Execute in a subshell so the working directory is not permanantly changed
    cd "${HOME}/Downloads" || exit

    get_sudo "to install ${application_name}"

    if [[ "${application_name}" == "OverSight" ]]; then

      if sudo bash -c "./${application_name}_Installer.app/Contents/MacOS/${application_name}_Installer -install"; then
      # OverSight's installer binary is name differently to other Obj-S installers
      # filename has an underscore instead of a space before "Installer"
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi
    
    elif [[ "${application_name}" == "BlockBlock" || \
            "${application_name}" == "ReiKey"     || \
            "${application_name}" == "Do Not Disturb" ]]; then

      if sudo bash -c "./${application_name}\\ Installer.app/Contents/MacOS/${application_name}\\ Installer -install"; then
      # Normal filename format of of Obj-S installer binaries
        echo "[‚úÖ] Successfully installed ${application_name}"
      else
        echo "[‚ùå] Failed to install ${application_name}"
        exit 1
      fi
    fi

  )
}


function get_sudo {

  # Ask user to input password to get sudo privilege
  # Update user's cached credentials, adds five (5)
  #   minutes to sudo timeout (-v)
  # Paramter: 
  #  $purpose_string REQUIRED
  #   Descibe why sudo is needed 

  local purpose_string=${1:?$purpose_string not passed to get_sudo}  
  
  if sudo --prompt="[‚ö†Ô∏è ] Password required ${purpose_string}: " -v; then
    # !! SUDO !!
    return 0
  else 
    return 1
  fi
}


function ctrl_c {
  # ctrl_c
  #   If user hits CTRL + C exit 
  echo -e "\\n[‚ùå] ${USER} has chosen to quit!"
  exit 1
}


function run_test {

  ./test
}


### END Utility Functions ###


function write_defaults {

  echo "[üç∫] Writing system & application defaults"
  
  get_sudo "to disable Guest User via defaults"

  defaults write com.apple.TextEdit RichText -bool false
  # TextEdit: Use Plain Text Mode as Default
  # Default: com.apple.TextEdit RichText -bool true

  defaults write com.apple.TextEdit TabWidth -int 4
  # TextEdit: Set tab width to 4 spaces
  # Default: n/a

  defaults write com.apple.menuextra.battery ShowPercent -bool true
  # Menu Bar: Show battery percentage
  # Default: com.apple.menuextra.battery ShowPercent -bool false

  defaults write -g NSNavPanelExpandedStateForSaveMode -bool true
  defaults write -g NSNavPanelExpandedStateForSaveMode2 -bool true
  # Save Panel: Show expanded version 
  # Default: defaults write -g NSNavPanelExpandedStateForSaveMode -bool false && \
  # defaults write -g NSNavPanelExpandedStateForSaveMode2 -bool false

  defaults write com.apple.finder ShowStatusBar -bool true
  # Finder: Show the status bar
  # Default: defaults write com.apple.finder ShowStatusBar -bool false

  defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool true
  # Trackpad: Enable three finger drag
  # Default: defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool false

  defaults write com.apple.AppleMultitouchTrackpad Clicking -bool true
  # Trackpad: Enable tap to click
  # Default: defaults write com.apple.AppleMultitouchTrackpad Clicking -bool false

  sudo defaults write /Library/Preferences/com.apple.AppleFileServer guestAccess -bool false
  # !! SUDO !!
  # Guest User: Disable
  # Default: sudo defaults write /Library/Preferences/com.apple.AppleFileServer guestAccess -bool true

  defaults write com.apple.menuextra.clock DateFormat -string "EEE d MMM  HH:mm"
  # Clock: Set format to Sun 26 Nov 16:00 

  defaults write com.apple.lookup.shared LookupSuggestionsDisabled -bool true
  # Spotlight: Disable suggestions in Lookup
  # Default: defaults write com.apple.lookup.shared LookupSuggestionsDisabled -bool false

  defaults write com.apple.mail PreferPlainText -bool true
  # Mail: Force emails to be opened in plain text
  # Default: defaults write com.apple.mail PreferPlainText -bool false

  defaults write com.apple.mail SendFormat -string Plain
  # Mail: Force new emails to be composed as plain text
  # Default: defaults write com.apple.mail SendFormat -string MIME

  defaults write com.apple.mail minSizeKB 5000
  # Mail: If attatchment is over 5MB ask to send via Mail Drop
  # Default: com.apple.mail minSizeKB 20000

  defaults write com.apple.ActivityMonitor IconType -int 5
  # Activity Monitor: Set dock icon to "Show CPU Usage"
  # Default: n/a

  defaults write com.apple.finder FXRemoveOldTrashItems -bool true
  # Finder: Empty trash after 30 days
  # Default: defaults write com.apple.finder FXRemoveOldTrashItems -bool false
}


function install_dotfiles {
  # install_dotfiles
  #   Create directories in $HOME
  #   Soft links config files from repo into $HOME
  #   Config files for: zsh, git, ssh, gpg
  
  local -r dir=$(pwd)
  local -ar dot_dirs=(.ssh .gnupg .extra)
  local dot_dir
  local -ar dot_files=(.zshrc .exports .functions \
                      .gitignore_global .gitconfig \
                      .aliases)
  local dot_file
  local -ar ssh_configs=(config)
  local ssh_config
  local -ar gpg_files=(gpg-agent.conf gpg.conf)
  local gpg_file

  # Create required directories 
  for dot_dir in "${dot_dirs[@]}"; do
    if mkdir -p "${HOME}/${dot_dir}"; then
      echo "[‚úÖ] Successfully created ${HOME}/${dot_dir}"
    else
      echo "[‚ùå] Failed to create ${HOME}/${dot_dir}"
    fi
  done

  # Symlink general dotfiles into $HOME
  for dot_file in "${dot_files[@]}"; do
      if ln -sfn "${dir}/${dot_file}" "${HOME}/${dot_file}"; then
        echo "[‚úÖ] Successfully linked ${dir}/${dot_file} to ${HOME}/${dot_file}"
      else
        echo "[‚ùå] Failed to link ${dir}/${dot_file} to ${HOME}/${dot_file}"
      fi
  done

  # Symlink ssh config in to $HOME/.ssh/
  for ssh_config in "${ssh_configs[@]}"; do
    if ln -sfn "${dir}/.ssh/${ssh_config}" "${HOME}/.ssh/${ssh_config}"; then
      echo "[‚úÖ] Successfully linked ${ssh_config} to ${HOME}/.ssh/${ssh_config}"
    else
      echo "[‚ùå] Failed to link ${ssh_config} to ${HOME}/.ssh/${ssh_config}"
    fi
  done

  # Symlink GPG config files in to $HOME/.gnupg/
  for gpg_file in "${gpg_files[@]}"; do
    if ln -sfn "${dir}/.gnupg/${gpg_file}" "${HOME}/.gnupg/${gpg_file}"; then
      echo "[‚úÖ] Successfully linked ${gpg_file} to ${HOME}/.gnupg/${gpg_file}"
    else
      echo "[‚ùå] Failed to link ${gpg_file} to ${HOME}/.gnupg/${gpg_file}"
    fi
  done 
}


function install_scripts {
  # install_scripts
  #   Symlink dotfiles/bin/ scripts into /usr/local/bin
  #   Create /usr/local/bin
  #   Symlink files in /usr/local/bin
  
  local -r dir=$(pwd)
  local -ar bin_files=(dns pihole_stats sublime_backup) 
  
  # Create /usr/local/bin
  if ! [[ -d "/usr/local/bin/" ]]; then 
    get_sudo "to create /usr/local/bin/"
    if sudo mkdir -p "/usr/local/bin/"; then
      echo "[‚úÖ] Successfully created /usr/local/bin/"
    else
      echo "[‚ùå] Failed to create /usr/local/bin/"
    fi
  fi

  # Symlink files
  get_sudo "to symlink scripts into /usr/local/bin/"
  for bin_file in "${bin_files[@]}"; do
      echo "[‚úÖ] Successfully linked ${bin_file} to /usr/local/bin/${bin_file_base}"
    if sudo sudo ln -sfn "${dir}/bin/${bin_file}" "/usr/local/bin/${bin_file}"; then
    else
      echo "[‚ùå] Failed to link ${bin_file} to /usr/local/bin/${bin_file_base}"
    fi
  done
}


function enable_touchid_sudo {
  # enable_touchid_sudo
  #   Check if already enabled in /etc pam.d/sudo
  #   Use vim to insert required text to sudo
  
  if grep -q 'pam_tid.so' /etc/pam.d/sudo; then
    echo "[‚úÖ] TouchID Sudo Already Enabled"
    return 0
  fi
    
  if sudo ex -s -c '2i|auth       sufficient     pam_tid.so' -c x! -c x! /etc/pam.d/sudo; then
    # Invoke Vim in ex mode
    # Select line 2, enter insert mode, insert that text write changes and exit
    # Need to exit twice to get passed the read only file warning
    echo "[‚úÖ] TouchID Sudo Enabled"
  else
    echo "[‚ùå] Failed to enable TouchID Sudo"
  fi
}


function install_gpgtools {
  
  if ! [ -x "$(command -v gpg2)" ]; then

    echo "[üç∫] Installing GPGTools (GPG Suite)"

    # shellcheck disable=SC2155
    local latest_version="$(curl -s "https://gpgtools.org/releases/gpgsuite/release-notes.html" \
                | grep -m 1 'class="version"' \
                | awk -F '"' '{print $(NF-1)}')"
    # Get the latest version string
    # Query the id field from the latest div class="version"
    local -r dmg_name="GPG_Suite-${latest_version}.dmg"
    local -r dmg_download_path="${HOME}/Downloads/${dmg_name}" 
    # shellcheck disable=SC2155
    local dmg_sha256="$(curl -s "https://gpgtools.org" 2>/dev/null \
              | grep -m 1 "SHA256" \
              | perl -nle "print $& if m{(?<=class='tooltiptext'>).*(?=</span></span>)}")"
    # Get the SHA256 hash of the latest DMG
    local -r dmg_mount_point="/Volumes/GPG Suite/" 

    echo "[üç∫] Downloading ${dmg_name}"
    if curl --silent "https://releases.gpgtools.org/${dmg_name}" --output "${dmg_download_path}" ; then 
    # Download 
      echo "[‚úÖ] Successfully downloaded ${dmg_name}"
    else
      echo "[‚ùå] Failed to download ${dmg_name}"
      exit 1
    fi

    verify_sha "${dmg_name}" "${dmg_download_path}" "256" "${dmg_sha256}"

    echo "[üç∫] Attempting to mount ${dmg_download_path}"
    if hdiutil attach -quiet "${dmg_download_path}"; then
    # Attempt to mount the DMG 
      echo "[‚úÖ] Successfully mounted ${dmg_name}"
    else
      echo "[‚ùå] Failed to mount ${dmg_name}"
      exit 1
    fi  

    verify_signature "${dmg_mount_point}/Install.pkg" "Install"
    
    get_sudo "to install GPGTools"

    if sudo installer -pkg "${dmg_mount_point}/Install.pkg" -target "/" >/dev/null; then
      # !! SUDO !!
      # Install
      echo "[‚úÖ] Successfully installed GPGTools"
    else
      echo "[‚ùå] Failed to install GPGTools"
      exit 1
    fi

    # Cleanup 
    echo "[üç∫] Unmounting ${dmg_mount_point}"
    hdiutil detach -quiet "${dmg_mount_point}"
    # Unmount the DMG
    
    echo "[üç∫] Deleting ${dmg_download_path}"
    rm "${dmg_download_path:?}"
    # Delete the DMG

  else
    echo "[üç∫] $(gpg2 --version | head -n 1) already installed"
  fi
}


function install_sublime_text {

  if [ ! -d "/Applications/Sublime Text.app" ]; then

    echo "[üç∫] Installing Sublime Text"

    local latest_build  
    latest_build="$(curl -s https://www.sublimetext.com/3 \
                | grep "Version:" \
                | awk '{print ($4+0)}')"
    # Get the latest build string
    # grep "Version:" \ : <p class="latest"><i>Version:</i> Build 3143</p>
    # awk '{print $4}' : 3143</p>
    # awk '{print ($4+0)}' : 3143
    # ($4+0) converts captured string to numeric
    local dmg_name="Sublime Text Build ${latest_build}.dmg"
    local dmg_download_path="${HOME}/Downloads/${dmg_name}"
    local dmg_mount_point="/Volumes/Sublime Text" 
    
    download_application "${dmg_download_path}" "https://download.sublimetext.com/Sublime%20Text%20Build%20${latest_build}.dmg"

    install_application "Sublime Text" "${dmg_download_path}"

    ## Install config files
    echo "[üç∫] Installing Sublime Text config files"

    if mkdir -p "$HOME/Library/Application Support/Sublime Text 3/Packages/"; then
      echo "[‚úÖ] Successfully created ~/Library/Application Support/Sublime Text 3/Packages/"
    else
      echo "[‚ùå] Failed to create ~/Library/Application Support/Sublime Text 3/Packages/"
      exit 1
    fi 

    if cp -r "Sublime Text 3/Packages/User" "$HOME/Library/Application Support/Sublime Text 3/Packages"; then
      echo "[‚úÖ] Successfully installed Sublime Text config files"
    else
      echo "[‚ùå] Failed to install Sublime Text config files"
      exit 1
    fi

  else 
    echo "[üç∫] Sublime Text already installed"
  fi
}


function install_tower {

  if [ ! -d "/Applications/Tower.app" ]; then
    
    echo "[üç∫] Installing Tower"

    local url
    local zip_name
    local zip_download_path

    url="$(curl -s https://updates.fournova.com/tower2-mac/stable/releases/latest/download | awk -F '"' '{print $2}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $7}')"
    zip_download_path="${HOME}/Downloads/${zip_name}" 

    download_application "${zip_download_path}" "${url}"

    install_application "Tower" "${zip_download_path}"
  
  else 
    echo "[üç∫] Tower already installed"
  fi
}


function  install_deckset {

  echo "[üç∫] Installing Deckset"
  
  local -r url="https://www.decksetapp.com/download"
  local dmg_name
  local dmg_download_path

  dmg_name="$(curl -sLI https://www.decksetapp.com/download \
              | grep 'location: ' | tail -n 1 \
              | awk -F '/' '{print $4}')"
  dmg_download_path="${HOME}/Downloads/${dmg_name}"

  download_application "${dmg_download_path}" "${url}"

  install_application "Deckset" "${dmg_download_path}"
}


function install_blockblock {
  # install_blockblock
  #   Installs BlockBlock via the usual helpers
  #   as wel as objective_see_install
  #   BB installer binary has a different name
  #   to the other Obj-s tools


  if [ -d "/Library/Objective-See/BlockBlock/BlockBlock.app" ]; then
    echo "[üç∫] BlockBlock already installed"
    return 0
  fi
    
    echo "[üç∫] Installing BlockBlock"
  
    local url
    local zip_name
    local zip_download_path
    local zip_sha1

    url="$(curl -s --compressed https://objective-see.com/products/blockblock.html \
           | grep -m 1 'downloads/BlockBlock' \
           | awk -F '"' '{print $2}')"
    zip_name="$(echo "${url}" | awk -F '/' '{print $NF}')"
    zip_download_path="${HOME}/Downloads/${zip_name}"
    zip_sha1="$(curl -s --compressed https://objective-see.com/products/blockblock.html \
                  | grep 'SHA-1' \
                  | awk '{print $4}')"

    download_application "${zip_download_path}" "${url}"

    verify_sha "${zip_name}" "${zip_download_path}" "1" "${zip_sha1}"

    objective_see_install "BlockBlock" "${zip_download_path}"

    # Enable headless mode
    defaults write com.objectiveSee.BlockBlock headlessMode -int 1
}


function install_oversight {

  # Install OverSight

  if [ -f "$HOME/Library/Preferences/com.objective-see.OverSight.plist" ]; then
    echo "[üç∫] OverSight already installed"
    return 0
  fi

  echo "[üç∫] Installing OverSight üì∏üé§"

  local url
  local zip_name
  local zip_download_path
  local zip_sha1

  url="$(curl -s --compressed https://objective-see.com/products/oversight.html \
        | grep -m 1 'downloads/OverSight' \
        | awk -F '"' '{print $2}')"
  zip_name="$(echo "${url}" | awk -F '/' '{print $NF}')"
  zip_download_path="${HOME}/Downloads/${zip_name}"
  zip_sha1="$(curl -s --compressed https://objective-see.com/products/oversight.html \
            | grep 'sha-1' \
            | awk '{print $3}')"

  download_application "${zip_download_path}" "${url}"

  verify_sha "${zip_name}" "${zip_download_path}" "1" "${zip_sha1}"

  objective_see_install "OverSight" "${zip_download_path}"

  # Enable headless mode
  defaults write com.objective-see.OverSight runHeadless -int 1
} 


function install_brew {

  # Install Homebrew and Homebrew-file

  if ! [ -x "$(command -v brew)" ]; then

    echo "[üç∫] Installing Homebrew"
    echo -e "[‚ö†Ô∏è ] \\033[0;31mStick around\\033[0m - Requires you to press RETURN and input your password"
    sleep 5

    if /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"; then
      echo "[‚úÖ] Successfully installed Homebrew üçª"
    else
      echo "[‚ùå] Failed to install Homebrew üò¢"
      exit 1
    fi    

  else

    echo "[üç∫] Updating Homebrew"
    sleep 2
    
    brew update
    brew upgrade
    brew cleanup
  fi

  echo "[üç∫] Installing Homebrew-file"

  if ! [ -x "$(command -v brew-file)" ]; then

    if brew install rcmdnk/file/brew-file; then
      echo "[‚úÖ] Successfully installed Homebrew-file"
    else
      echo "[‚ùå] Failed to install Homebrew-file"
      exit 1
    fi

  else
    echo "[üç∫] Homebrew-file already installed"
  fi 
}


function install_brewfile {

  # Install Homebrew packages from dotfiles/.extra/Brewfile
  # Will install programs from the Mac AppStore if user is logged in

  declare -x HOMEBREW_BREWFILE="${HOME}/Documents/Projects/dotfiles/.extra/Brewfile"

  echo "[üç∫] Installing mas"

  if brew install mas 2>/dev/null; then
    echo "[‚úÖ] Installed mas"
  else
    echo "[‚ùå] Failed to install mas"
    return 1
  fi

  echo "[üç∫] Exported HOMEBREW_BREWFILE=${HOMEBREW_BREWFILE}"
  echo "[üç∫] Installing Homebrew packages from Brewfile"
  
  get_sudo "to install software via Homebrew"

  if brew file install; then 
    echo "[‚úÖ] Successfully installed packages from Brewfile"
    return 0
  else
    echo "[‚ùå] Failed to install packages from Brewfile"
    return 1
  fi
}


function change_shell {
  # change_shell
  #   Change default shell to zsh as installed by Brew
  #   /usr/local/bin/zsh instead of /bin/zsh

  local -r new_shell="/usr/local/bin/zsh"
  
  if [[ "${SHELL}" == "${new_shell}" ]]; then
    echo "[‚úÖ] Current shell is already '${new_shell}'"
    return 0
  fi

  get_sudo "to change shell"

  if [[ ! -e "${new_shell}" ]]; then
    echo "[‚ùå] Failed to change shell as '${new_shell}' does not exist"
    return 1
  fi

  if ! sudo bash -c "echo ${new_shell} >> /etc/shells"; then
    # !! SUDO !!
    # Add new shell to list of allowed shells
    # https://unix.stackexchange.com/a/4833/271903
    echo "[‚ùå] Failed to add ${new_shell} to /etc/shells"
    return 1
  fi
  
  if chsh -s "${new_shell}"; then
  # Change $USER shell
    echo "[‚úÖ] Successfully change default shell to ${new_shell}"
    return 0
  else  
    echo "[‚ùå] Failed to change default shell to ${new_shell}"
    return 1
  fi
}


function main {

  check_os_compatibility
  check_developer_tools

  local cmd=${1:-"usage"}

  trap ctrl_c SIGINT
  # Detect and react to the user hitting CTRL + C

  if [[ "${cmd}" == "defaults" ]]; then
    write_defaults

  elif [[ "${cmd}" == "dotfiles" ]]; then
    install_dotfiles

  elif [[ "${cmd}" == "scripts" ]]; then
    install_scripts

  elif [[ "${cmd}" == "sudotouch" ]]; then
    enable_touchid_sudo

  elif [[ "${cmd}" == "gpgtools" ]]; then 
    install_gpgtools

  elif [[ "${cmd}" == "sublimetext" ]]; then
    install_sublime_text 

  elif [[ "${cmd}" == "tower" ]]; then
    install_tower

  elif [[ "${cmd}" == "deckset" ]]; then
    install_deckset

  elif [[ "${cmd}" == "blockblock" ]]; then
    install_blockblock
  
  elif [[ "${cmd}" == "oversight" ]]; then
    install_oversight

  elif [[ "${cmd}" == "brew" ]]; then
    install_brew

  elif [[ "${cmd}" == "brewfile" ]]; then
    install_brewfile

  elif [[ "${cmd}" == "shell" ]]; then
    change_shell

  elif [[ "${cmd}" == "test" ]]; then
    run_test

  elif [[ "${cmd}" == "hailmary" ]]; then
    # Execute all the functions
    # Order matters!
    # TODO: Manually adding new functions sucks 
    echo -e "[üç∫] ${RED}Hailmary${RESET} engaged"
    sleep 3

    write_defaults
    install_dotfiles
    install_scripts
    enable_touchid_sudo
    install_gpgtools
    install_sublime_text
    install_tower
    install_deckset
    install_blockblock
    install_oversight
    install_brew
    install_brewfile
    change_shell

  else
    usage
  fi
}

main "$@"
